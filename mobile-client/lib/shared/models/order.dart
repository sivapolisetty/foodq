import 'package:freezed_annotation/freezed_annotation.dart';

part 'order.freezed.dart';
part 'order.g.dart';

/// Order status enum
enum OrderStatus {
  @JsonValue('pending')
  pending,
  @JsonValue('confirmed')
  confirmed,
  @JsonValue('preparing')
  preparing,
  @JsonValue('ready')
  ready,
  @JsonValue('completed')
  completed,
  @JsonValue('cancelled')
  cancelled,
}

/// Payment status enum
enum PaymentStatus {
  @JsonValue('pending')
  pending,
  @JsonValue('paid')
  paid,
  @JsonValue('failed')
  failed,
  @JsonValue('refunded')
  refunded,
}

/// Payment method enum
enum PaymentMethod {
  @JsonValue('cash')
  cash,
  @JsonValue('card')
  card,
  @JsonValue('digital')
  digital,
}

/// Extension methods for Order enums
extension OrderStatusExtension on OrderStatus {
  String get displayText {
    switch (this) {
      case OrderStatus.pending:
        return 'Pending';
      case OrderStatus.confirmed:
        return 'Confirmed';
      case OrderStatus.preparing:
        return 'Preparing';
      case OrderStatus.ready:
        return 'Ready for Pickup';
      case OrderStatus.completed:
        return 'Completed';
      case OrderStatus.cancelled:
        return 'Cancelled';
    }
  }
}

extension PaymentStatusExtension on PaymentStatus {
  String get displayText {
    switch (this) {
      case PaymentStatus.pending:
        return 'Pending';
      case PaymentStatus.paid:
        return 'Paid';
      case PaymentStatus.failed:
        return 'Failed';
      case PaymentStatus.refunded:
        return 'Refunded';
    }
  }
}

extension PaymentMethodExtension on PaymentMethod {
  String get displayText {
    switch (this) {
      case PaymentMethod.cash:
        return 'Cash';
      case PaymentMethod.card:
        return 'Card';
      case PaymentMethod.digital:
        return 'Digital';
    }
  }
}

/// Order type enum
enum OrderType {
  @JsonValue('pickup')
  pickup,
  @JsonValue('delivery')
  delivery,
}

/// Business info for order
@freezed
class OrderBusiness with _$OrderBusiness {
  const factory OrderBusiness({
    required String id,
    required String name,
    String? phone,
    String? address,
    @JsonKey(name: 'image_url') String? imageUrl,
  }) = _OrderBusiness;

  factory OrderBusiness.fromJson(Map<String, dynamic> json) => _$OrderBusinessFromJson(json);
}

/// Deal info for order item
@freezed
class OrderDeal with _$OrderDeal {
  const factory OrderDeal({
    required String id,
    required String title,
    String? description,
    @JsonKey(name: 'image_url') String? imageUrl,
  }) = _OrderDeal;

  factory OrderDeal.fromJson(Map<String, dynamic> json) => _$OrderDealFromJson(json);
}

/// Order item
@freezed
class OrderItem with _$OrderItem {
  const factory OrderItem({
    required String id,
    @JsonKey(name: 'order_id') required String orderId,
    @JsonKey(name: 'deal_id') required String dealId,
    required int quantity,
    required double price,
    String? notes,
    @JsonKey(name: 'created_at') DateTime? createdAt,
    OrderDeal? deals, // Nested deal info from API
  }) = _OrderItem;

  factory OrderItem.fromJson(Map<String, dynamic> json) => _$OrderItemFromJson(json);
}

/// Order model for pick-up orders
@freezed
class Order with _$Order {
  const factory Order({
    required String id,
    @JsonKey(name: 'user_id') required String userId,
    @JsonKey(name: 'business_id') required String businessId,
    @JsonKey(name: 'total_amount') required double totalAmount,
    required OrderStatus status,
    @JsonKey(name: 'delivery_address') String? deliveryAddress,
    @JsonKey(name: 'delivery_instructions') String? deliveryInstructions,
    @JsonKey(name: 'pickup_time') DateTime? pickupTime,
    @JsonKey(name: 'payment_method') required PaymentMethod paymentMethod,
    @JsonKey(name: 'payment_status') @Default(PaymentStatus.pending) PaymentStatus paymentStatus,
    @JsonKey(name: 'created_at') DateTime? createdAt,
    @JsonKey(name: 'updated_at') DateTime? updatedAt,
    // Nested data from API
    OrderBusiness? businesses,
    @JsonKey(name: 'order_items') @Default([]) List<OrderItem> orderItems,
  }) = _Order;

  factory Order.fromJson(Map<String, dynamic> json) => _$OrderFromJson(json);

  const Order._();

  /// Create a new pick-up order
  factory Order.createPickupOrder({
    required String userId,
    required String businessId,
    required double totalAmount,
    DateTime? pickupTime,
    String? deliveryInstructions,
    PaymentMethod paymentMethod = PaymentMethod.cash,
  }) {
    return Order(
      id: '', // Will be generated by database
      userId: userId,
      businessId: businessId,
      totalAmount: totalAmount,
      status: OrderStatus.pending,
      pickupTime: pickupTime,
      deliveryInstructions: deliveryInstructions,
      paymentStatus: PaymentStatus.pending,
      paymentMethod: paymentMethod,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      orderItems: [],
    );
  }

  /// Get order status display text
  String get statusDisplay {
    switch (status) {
      case OrderStatus.pending:
        return 'Pending Confirmation';
      case OrderStatus.confirmed:
        return 'Confirmed';
      case OrderStatus.preparing:
        return 'Being Prepared';
      case OrderStatus.ready:
        return 'Ready for Pickup';
      case OrderStatus.completed:
        return 'Completed';
      case OrderStatus.cancelled:
        return 'Cancelled';
    }
  }

  /// Get payment status display text
  String get paymentStatusDisplay {
    switch (paymentStatus) {
      case PaymentStatus.pending:
        return 'Payment Pending';
      case PaymentStatus.paid:
        return 'Paid';
      case PaymentStatus.failed:
        return 'Payment Failed';
      case PaymentStatus.refunded:
        return 'Refunded';
    }
  }

  /// Get payment method display text
  String get paymentMethodDisplay {
    switch (paymentMethod) {
      case PaymentMethod.cash:
        return 'Cash on Pickup';
      case PaymentMethod.card:
        return 'Credit/Debit Card';
      case PaymentMethod.digital:
        return 'Digital Payment';
    }
  }

  /// Check if order can be cancelled
  bool get canBeCancelled {
    return status == OrderStatus.pending || status == OrderStatus.confirmed;
  }

  /// Check if order is active (not completed or cancelled)
  bool get isActive {
    return status != OrderStatus.completed && status != OrderStatus.cancelled;
  }

  /// Get formatted total amount
  String get formattedTotal {
    return '\$${totalAmount.toStringAsFixed(2)}';
  }

  /// Get the first deal title from order items
  String get dealTitle {
    if (orderItems.isNotEmpty && orderItems.first.deals != null) {
      return orderItems.first.deals!.title;
    }
    return 'Unknown Deal';
  }

  /// Get the first deal image URL from order items  
  String? get dealImageUrl {
    if (orderItems.isNotEmpty && orderItems.first.deals != null) {
      return orderItems.first.deals!.imageUrl;
    }
    return null;
  }

  /// Get business name
  String get businessName {
    return businesses?.name ?? 'Unknown Business';
  }

  /// Get total quantity from all order items
  int get totalQuantity {
    return orderItems.fold(0, (sum, item) => sum + item.quantity);
  }

  /// Get formatted pickup time
  String get formattedPickupTime {
    if (pickupTime == null) return 'Not specified';
    
    final now = DateTime.now();
    final pickup = pickupTime!;
    
    if (pickup.day == now.day && pickup.month == now.month && pickup.year == now.year) {
      // Today
      return 'Today at ${pickup.hour.toString().padLeft(2, '0')}:${pickup.minute.toString().padLeft(2, '0')}';
    } else if (pickup.day == now.day + 1 && pickup.month == now.month && pickup.year == now.year) {
      // Tomorrow
      return 'Tomorrow at ${pickup.hour.toString().padLeft(2, '0')}:${pickup.minute.toString().padLeft(2, '0')}';
    } else {
      // Other date
      return '${pickup.day}/${pickup.month}/${pickup.year} at ${pickup.hour.toString().padLeft(2, '0')}:${pickup.minute.toString().padLeft(2, '0')}';
    }
  }

  /// Get order progress percentage
  double get progressPercentage {
    switch (status) {
      case OrderStatus.pending:
        return 0.2;
      case OrderStatus.confirmed:
        return 0.4;
      case OrderStatus.preparing:
        return 0.6;
      case OrderStatus.ready:
        return 0.8;
      case OrderStatus.completed:
        return 1.0;
      case OrderStatus.cancelled:
        return 0.0;
    }
  }

  /// Get estimated preparation time in minutes
  int get estimatedPrepTime {
    // This could be enhanced to use deal-specific prep times
    return 15; // Default 15 minutes
  }
}

/// Order with related data for display
@freezed
class OrderWithDetails with _$OrderWithDetails {
  const factory OrderWithDetails({
    required Order order,
    String? dealTitle,
    String? dealImageUrl,
    String? businessName,
    String? businessAddress,
    String? businessPhone,
  }) = _OrderWithDetails;

  factory OrderWithDetails.fromJson(Map<String, dynamic> json) => _$OrderWithDetailsFromJson(json);
}